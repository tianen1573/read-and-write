# C++

#### 指针与引用

> 1. 本质: 指针是一个变量，存储内容是一个地址，指向内存的一个存储单元。而引用是原变量的一个别名，实质上和原变量是一个东西，是某块内存的别名。
> 2. 指针的值可以为空，且非const指针可以被重新赋值以指向另一个不同的对象。而引用的值不能为空，并且引用在定义的时候必须初始化，一旦初始化，就和原变量“绑定”，不能更改这个绑定关系。
> 3. 对指针执行sizeof()操作得到的是指针本身的大小（32位系统为4,64位系统为8）。而对引用执行sizeof()操作得到的是所绑定的对象的所占内存大小。
> 4. 指针的自增(++)运算表示对地址的自增，自增大小要看所指向单元的类型。而引用的自增(++)运算表示对值的自增。
> 5. 在作为函数参数进行传递时的区别: 指针所以函数传输作为传递时，函数内部的指针形参是指针实参的一个副本，改变指针形参并不能改变指针实参的值，通过解引用*运算符来更改指针所指向的内存单元里的数据。而引用在作为函数参数进行传递时，实质上传递的是实参本身，即传递进来的不是实参的一个拷贝，因此对形参的修改其实是对实参的修改，所以在用引用进行参数传递时，不仅节约时间，而且可以节约空间。

#### define和typedef

**define**

> 1. 只是简单的字符串替换，没有类型检查
> 2. 在预处理阶段起作用：进行替换
> 3. 不分配内存，给的是立即数，有多少次使用就进行多少次替换(预处理阶段)

**typedef**

> 1. typedef定义了一个新的数据类型，进行类型检查
>     ~~~C++
>     typedef char* PSTR;
>     int mystrcmp(const PSTR, const PSTR);
>     const PSTR != const char*;
>     const PSTR == char* const;
>     ~~~
>
>     
>
> 2. 在编译的时候起作用
>
> 3. typedef定义出来的是变量，分配内存空间，在程序运行过程中内存里只有一个拷贝

#### define和inline

**define**

> define宏是字符串替换，无类型检查，不安全

**inline**

> 1. C++的建议型关键字，编译器可以拒绝
>
> 2. 内联函数是⼀种特殊的函数，会进⾏类型检查
> 3. `inline`函数与普通函数的区别在于，当编译器处理调用内联函数的语句时，不会将该语句编译成函数调用的指令，而是**直接将整个函数体的代码插人调用语句处**，就像整个函数体在调用处被重写了一遍一样。**中心思想是以空间换时间**
> 4. 都是讲代码插入的调用处，但inline是建议性的，并且有类型检查。
> 5. C++中inline编译限制
>
>     > 1. 不能存在任何形式的循环语句 
>     > 2. 不能存在过多的条件判断语句 
>     > 3. 函数体不能过于庞⼤ 
>     > 4. 内联函数声明必须在调⽤语句之前

#### 重载/重写/隐藏

>  ![image-20230726090406380](%E5%9B%BE%E7%89%87/README/image-20230726090406380.png)
>
> 重载：
>
> > - 在同一个作用域下，函数名相同，形参列表不同，则这些同名函数构成重载
> > - 不能根据返回值类型，访问权限判断两个函数是否构成重载
> > - 重载属于静态多态，即在编译阶段，就已经确定了调用哪一个重载函数
>
> 隐藏(重定义)：
>
> > - 在不同作用域下(父类，子类)，函数名相同的两个函数构成隐藏(重定义)
> > - 当两个函数构成隐藏时，父类的同名函数会被隐藏，当用子类的对象调用同名函数时，若不指定类作用符，默认调用子类的同名函数
> > - 同名成员对象也构成隐藏
>
> 重写(覆盖)：
>
> > - 在不同作用域下(父类，子类)，函数的函数名，形参列表，返回值类型完全相同，且父类必须指明virtual
> >
> > - 重写的两个例外：(1)析构函数为虚函数时，父子类的析构函数名不需要相同，但编译器对析构函数的名称做了特殊处理，编译后析构函数的名称统一处理成destructor；(2)协变，即基类虚函数返回基类对象的指 针或者引用，派生类虚函数返回派生类对象的指针或者引用时，称为协变，此时返回值类型不同，但也构成重写。
> > - 构造函数和静态函数不能定义为虚函数，实现重现，前者在对象构造完成前调用，不存在vptr；后者没有this指针，找不到对象的vptr

#### 基类析构函数为什么要定义为虚函数？

> 当基类指针指向派生类对象时，若基类的析构函数不定义为虚函数，则通过基类指针析构时，只会调用基类的析构函数而不会调用派生类的析构函数，此时派生类部分的内存就没有释放，从而导致内存泄漏
>
> 即，保护派生类资源安全释放

#### 构造函数为什么不能为虚函数？

> **和虚函数的调用逻辑有关**
>
> - 如果一个函数为虚函数，调用该函数，需要经过this指针找到虚函数表指针vptr，再通过vptr找到虚函数表，最后从虚函数表查找该虚函数对应的地址进行调用
> - 而vptr是在分配对象内存时存在的，即构造函数列表初始化阶段，此时属于调用了构造函数，但构造对象动作还未完成
> - 如果把构造函数定义为虚函数，则构造对象时需要先找到vptr，而vptr需要先构造才放入内存空间，逻辑矛盾

#### 浅拷贝与深拷贝

> - 深拷贝(Memberwise copy semantics)：需要自己按照真实逻辑自写拷贝代码，使源对象与拷贝对象互相独立，其中任何一个对象的改动都不会对另外一个对象造成影响
> - 浅拷贝(bitwise copy semantics)：又叫值拷贝，拷贝逻辑为仅仅按字节拷贝，可能导致源对象与拷贝对象可能指向了同一份资源，从而导致资源泄漏
> - 拷贝在类里面有指针成员的情况下只会复制指针的地址，会导致两个成员指针指向同一块内存，这样在要是分别delete释放时就会出现问题，因此需要用深拷贝
> - 如果在类中没有显式地声明一个拷贝构造函数，那么，编译器将会自动生成一个默认的拷贝构造函数，该构造函数完成对象之间的浅拷贝

#### C++如何避免内存泄漏

> - 使用RAII思想，通过栈对象的构造函数(申请资源)与析构函数(释放资源)，来管理资源
> - 相比于原生指针，推荐使用智能指针，如C++11的share_ptr，unique_ptr
> - 注意new/delete和new[]/delete[]的匹配使用
> - 完善类的拷贝构造，赋值重载构造函数，避免发生危险的浅拷贝，导致动态资源泄漏

#### C++静态变量初始化

> 在C++中，静态变量分为全局静态变量（又称全局变量）、局部静态变量（函数中的静态变量）和类中静态成员变量。按照初始化的类型分为静态初始化（static initialization）和动态初始化(dynamic initialization)
>
> 全局变量、文件域的静态变量和类的静态成员变量**在main执行之前的静态初始化过程中分配内存并初始化**；
>
> 局部静态变量（一般为函数内的静态变量）在**第一次使用时分配内存并初始化**。这里的变量包含内置数据类型和自定义类型的对象。
>
> **全局静态变量/全局变量/类的静态成员变量**
>
> > - **程序加载前初始化**，即编译时就已经初始化，分为静态初始化和动态初始化
>
> **局部静态变量**
>
> > - C语言中，和全局静态变量一样，程序加载前初始化
> > - C++中，**在执行相关代码时才会进行初始化**，主要是由于C++引入对象后，要进行初始化必须执行相应构造函数和析构函数，在构造函数或析构函数中经常会需要进行某些程序中需要进行的特定操作，并非简单地分配内存。**所以C++标准定为全局或静态对象是有首次用到时才会进行构造，并通过atexit()来管理。在C++中是可以使用变量对静态局部变量进行初始化的**
>
> 根据 C++ 标准，全局变量的初始化要在 main 函数执行前完成，常识无疑，但是这个说法有点含糊，main 函数执行前到底具体是什么时候呢？是编译时还是运行时？**答案是既有编译时，也可能会有运行时(seriously)**
>
> **静态初始化**
>
> > 静态初始化指的是用常量来对变量进行初始化,主要包括 zero initialization 和 const initialization，**静态初始化在程序加载的过程中完成**，对简单类型(内建类型，POD等)来说，从具体实现上看，zero initialization 的变量会被保存在 bss 段，const initialization 的变量则放在 data 段内，程序加载即可完成初始化，这和 c 语言里的全局变量初始化基本是一致的。
>
> **动态初始化**
>
> > 动态初始化主要是指需要经过函数调用才能完成的初始化，比如说：int a = foo()，或者是复杂类型（类）的初始化（需要调用构造函数）等。这些变量的初始化会**在 main 函数执行前由运行时调用相应的代码从而得以进行**(函数内的 static 变量除外)。
>
> ~~~C++
> class A
> {
> public:
> 	A()
> 	{
> 		cout << "I am A" << endl;
> 	}
> 	A(const A&a)
> 	{
> 		cout << "I am A : a" << endl;
> 	}
> 	~A()
> 	{
> 		cout << "I am ~A" << endl;
> 	}
> };
> class B
> {
> public:
> 	B()
> 	{
> 		cout << "I am B" << endl;
> 	}
> 	~B()
> 	{
> 		cout << "I am ~B" << endl;
> 	}
> 	static A a;
> };
> A B::a; // 1
> 
> int func()
> {
> 	static B b; // 3
> 	return 1;
> }
> int aaaa = func(); // 4
> B bb; // 2
> int main()
> {
> 	cout << "main()" << endl;
> 
> 	A aa;
> 	static A aaa = aa; // 5
> 	//func();
> 
> 	cout << "~main()" << endl;
> 	return 0;
> }
> ~~~

# 数据结构

###### map的底层数据结构是什么？为什么不是AVL

> map/set的底层数据结构是红黑树RBT。
>
> AVL树严格要求平衡，左右子树的高度差不能大于1；而RBT要求相对宽松，但也要求最长路径不能大于最短路径两倍
>
> 查找都是LOG级别
>
> 因为AVL严格要求平衡，则插入删除操作更大概率引发多次旋转操作；而红黑树的插入删除操作小概率引发少次旋转操作

# 面经

## 1

### C++

###### volatile

> 保证内存可⻅性。
>
> - 可⻅性是指线程之间的可⻅性，⼀个线程修改的状态对另⼀个线程是可⻅的。也就是⼀个线程修改的结果，另⼀个线程⻢上就能看到。
>
> 实现原理： 
>
> - （1）当对⾮volatile变量进⾏读写的时候，每个线程先从主内存拷⻉变量到CPU缓存中，如果计算机有多个CPU， 每个线程可能在不同的CPU上被处理，这意味着每个线程可以拷⻉到不同的CPU cache中。   
> - （2）volatile变量不会被缓存在寄存器或者对其他处理器不可⻅的地⽅，保证了每次读写变量都从主内存中读，跳过CPU cache这⼀步。当⼀个线程修改了这个变量的值，新值对于其他线程是⽴即得知的。 

### OS

###### 进程与线程的区别，进程通信方式

> 进程是系统资源的最小分配单位，创建进程需要分配地址空间+PCB(process control block)资源，切换复杂
>
> 线程是CPU调度的最小单位，创建线程只需要分配PCB资源，切换简单
>
> 并且，LINUX，进程与线程都是轻量级进程
>
> 进程的通信方式有：较熟悉的有管道，共享内存，不了解的有消息队列

###### 多进程与多线程的区别以及使用场景

> | 对比维度       | 多进程                                                       | 多线程                                                       | 总结     |
> | -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | -------- |
> | 数据共享，同步 | 数据共享复杂，需要使用IPC；数据独立，同步简单                | 因为共享进程数据，数据共享简单，但因此导致同步复杂           | 各有优势 |
> | 内存，CPU      | 占用内存多(每个进程都需要分配进程地址空间)，切换复杂，CPU利用老板低 | 占用内存少(多个线程共用一个进程地址空间)，切换简单，CPU利用率高 | 线程占优 |
> | 创建/销毁/切换 | 创建/销毁/切换复杂，速度慢(创建进程分配的资源多)，原因有：切换PCB，加载内存，打开文件 | 创建/销毁/切换简单，速度快，原因有：仅需要切换PCB，替换寄存器内容，栈内容 | 线程占优 |
> | 可靠性         | 进程间不会互相影响，稳定性高                                 | 一个线程出错会导致整个进程挂掉，稳定性差                     | 进程占优 |
> | 编程/调试      | 编程简单，调试简单                                           | 编程复杂，调试复杂，原因有：线程安全，资源共享               | 进程占优 |
> | 分布式         | 适用于多核多机                                               | 适用于多核                                                   |          |
> | 使用场景       | 系统稳定性要求严格：自动驾驶                                 | 大量计算任务(计算密集)；桌面软件(IO密集)；Web服务器          |          |
>
> [多线程和多进程 及其应用场景_多线程、多进程在实际工程中的用处](https://blog.csdn.net/weixin_39731083/article/details/82015830)
>
> 多进程的优点：
>
> 1. **编程相对容易**；通常不需要考虑锁和同步资源的问题。 
> 2. **更强的容错性**：比起多线程的一个好处是一个进程崩溃了不会影响其他进程。 
> 3. **有内核保证的隔离：数据和错误隔离**。 对于使用如C/C++这些语言编写的本地代码，错误隔离是非常有用的：采用多进程架构的程序一般可以做到一定程度的自恢复；（master守护进程监控所有worker进程，发现进程挂掉后将其重启）。
>
> 多线程的优点：
>
> 1. **创建速度快，方便高效的数据共享** 
>     共享数据：多线程间可以共享同一虚拟地址空间；多进程间的数据共享就需要用到共享内存、信号量等IPC技术。
> 2. **较轻的上下文切换开销** - 不用切换地址空间，不用更改寄存器，不用刷新TLB。 
> 3. **提供非均质的服务**。如果全都是计算任务，但每个任务的耗时不都为1s，而是1ms-1s之间波动；这样，多线程相比多进程的优势就体现出来，它能有效降
>
> 选什么？
>
> 1. **需要频繁创建销毁的优先用线程（进程的创建和销毁开销过大）**
>     这种原则最常见的应用就是Web服务器了，来一个连接建立一个线程，断了就销毁线程，要是用进程，创建和销毁的代价是很难承受的
> 2. **需要进行大量计算的优先使用线程（CPU频繁切换）**
>     所谓大量计算，当然就是要耗费很多CPU，切换频繁了，这种情况下线程是最合适的。
>     这种原则最常见的是图像处理、算法处理。
> 3. **强相关的处理用线程，弱相关的处理用进程**
>     什么叫强相关、弱相关？理论上很难定义，给个简单的例子就明白了。
>     一般的Server需要完成如下任务：消息收发、消息处理。“消息收发”和“消息处理”就是弱相关的任务，而“消息处理”里面可能又分为“消息解码”、“业务处理”，这两个任务相对来说相关性就要强多了。因此“消息收发”和“消息处理”可以分进程设计，“消息解码”、“业务处理”可以分线程设计。
>     当然这种划分方式不是一成不变的，也可以根据实际情况进行调整。
> 4. **多机分布的用进程，多核分布的用线程**
> 5. 一个选择原则：如果多进程和多线程都能够满足要求，那么选择你最熟悉、最拿手的那个。

### 计网

###### http和https的区别

> **端口**
>
> > HTTP的URL由`http://`起始且默认使用端口80
> >
> > HTTPS的URL由`https://`起始且默认使用端口443
>
> 安全性和资源消耗
>
> > HTTP协议运行在TCP(UDP)之上，传输的内容都是明文，客户端和服务器端都无法验证对方的身份
> >
> > HTTPS协议是运行在SSL/TLS之上的HTTP协议，SSL/TLS协议运行在TCP之上，传输的内容都是经过加密的，加密采用 CA认证+签名+非对称加密+对称加密 
> >
> > HTTP安全性没有HTTPS高，但是消耗的服务器资源比HTTPS低(加密解密都需要消耗资源)

###### HTTPS用到了那些加密技术

> 对称加密
>
> > 密钥只有一个，既可以加密也可以解密，且加密解密速度快，典型有：DES，AES
>
> 非对称加密
>
> > 密钥成对出现，分为公钥和私钥。加密解密使用不同密钥(私钥加密只能由公钥解密，公钥加密只能由私钥加密)，相对对称加密速度较慢，典型有：RSA，DSA
>
> CA认证签名+非对称加密+对称加密
>
> > 服务器向CA机构申请得到CA私钥加密后的证书，该证书里有服务器公钥
> >
> > 客户端链接服务器时会得到服务器的CA证书，使用公布的CA公钥来验证该证书的合法性
> >
> > 若证书合法，则证书里的服务器公钥要是合法的，此时客户端使用该公钥加密自己的对称密钥，返回给服务器
> >
> > 服务器得到后使用服务器私钥解密，这样CS都具有对称密钥，使用该密钥进行加密解密

###### 打开一个网页使用到了哪些协议？

> [一次完整的HTTP请求过程是怎么样的呢？](https://zhuanlan.zhihu.com/p/161560683)
>
> 概述
>
> > 1. **浏览器进行DNS域名解析，得到对应的IP地址**
> > 2. **根据这个IP，找到对应的服务器建立连接（三次握手）**
> > 3. **建立TCP连接后发起HTTP请求（一个完整的http请求报文）**
> > 4. **服务器响应HTTP请求，浏览器得到html代码（服务器如何响应）**
> > 5. **浏览器解析html代码，并请求html代码中的资源（如js、css、图片等）**
> > 6. **浏览器对页面进行渲染呈现给用户**
> > 7. **服务器关闭TCP连接（四次挥手）**
> > 8. **还可能用到ARP，NAT，ICMP协议**
>
> 详情
>
> > DNS查找IP：浏览器缓存，OS缓存，hosts文件，DNS服务器
> >
> > TCP协议：三次握手
> >
> > IP协议：路由转发
> >
> > HTTP协议：HTTP请求/响应
> >
> > ARP协议：IP转MAC地址
> >
> > NAT协议：IP转换
> >
> > ICMP协议：错误审查

###### DNS过程详情

> 域名的解析是⼀个从右向左的过程，并且域名都隐藏了一个默认的根域名服务器`.`
>
> `. -> .com -> google.com. -> www.google.com . `
>
> - 首先会在**浏览器的DNS缓存**中去查询是否有对应的记录，如果查询到记录就可以直接得到对应的IP地址，则完成解析。
> - 如果在浏览器的DNS缓存中没有找到，就会去查询**操作系统中的DNS缓存**，如果查询到对应的IP地址，则完成解析。
> - 如果在操作系统的DNS缓存中没有找到，就会去查找**本地的hosts文件**，如果查询到对应的IP地址，则完成解析。
> - 如果在本地的hosts文件中也没有找到，就会去**本地DNS服务器**中查找。本地DNS服务器IP地址一般由本地网络服务商提供，如电信、移动等公司，一般通过DHCP自动分配。目前使用的比较多的是谷歌提供的公用NDS 8.8.8.8和国内公用DNS 114.114.114.114。如果在本地DNS服务器中有对应域名的缓存，直接返回对应的IP地址，则完成解析。
> - 如果本地DNS服务器中仍然没有找到，那么本地DNS服务器就会拿着域名去**根DNS服务器**中询问，根DNS服务器会告诉本地DNS顶级域名服务器的IP地址。
> - 本地DNS拿到顶级域名服务器的IP地址后，就会拿着域名去找**顶级DNS服务器**，顶级域名服务器会告诉本地DNS权威域名服务器的IP地址。
> - 本地DNS服务器拿着域名去**权威域名服务器**中，查询域名对应的IP地址，最终将该域名对应的IP地址返回给浏览器，此时整个域名解析过程就完成了。

###### TCP四次挥⼿中，time-wait状态，close-wait状态，在哪⼀个阶段？

> 四次挥手
>
> > 1. 客户端发送 FIN
> >     
> >
> > 2. 服务器返回 ACK 号
> >
> >     
> >
> > 3. 服务器发送 FIN   
> >
> > 4. 客户端返回 ACK 号  
>
> 状态变化(建议画图)
>
> > 客户端发送FIN：⽤来申请关闭客户端到服务器的数据传送，此时 客户端进⼊**FIN_WAIT_1状态**，等待服务器发送ACK
> >
> > 服务器收到FIN：服务器收到客户端发送的FIN后，就会进入**CLOSE_WAIT状态**
> >
> > 服务器发送ACK：告知客户端自己收到了C->S链接断开的请求，此时 客户端发送服务器读取的链接关闭
> >
> > 客户端收到ACK：客户端进入**FIN_WAIT_2状态**，此时 客户端发送服务器读取的链接关闭
> >
> > 
> >
> > 服务器发送FIN：⽤来申请关闭服务器到客户端的数据传送，此时服务器进入**LASE_ACK状态**，等待客户端发送最后的ACK
> >
> > 客户端收到FIN：客户端收到服务器断开链接请求，客户端进入**TIME_WAIT状态**，并发送一个ACK
> >
> > 客户端发送ACK：等待两个MSL时间关闭S->C链接，然后关闭服务器发送客户端读取的链接
> >
> > 服务器收到ACK：关闭服务器发送客户端读取的链接
> >
> > 服务器没收到ACK：重新发送FIN
>
> ![image-20230724113908431](%E5%9B%BE%E7%89%87/README/image-20230724113908431.png)

###### TCP粘包拆包

> 包：应用层数据包
>
> 产生粘包的原因：
>
> > 应用层交给TCP的数据，是先放在TCP发送缓冲区，再由TCP协议控制发送的。而TCP发送数据时依赖滑动窗口，这就导致在发送时，数据报不一定是一个应用层数据包。
> >
> > 那么TCP接收端在接收到数据时，因为是面向字节流+没有报文长度字段，导致接收端也无法分辨是否是一个数据包，只能按照32位序列号进行排序。
> >
> > 在应用层读取时，需要从TCP接收缓冲区读取，TCP是面向字节流的，导致应用层读到的是一串数据，这些数据不能保证正正好好是一个数据包，只能保证宏观上有序。
> >
> > TCP的读取和发送是有水位线概念的，到达一定字节时，才允许从TCP读取和发送，粘包也能解决频繁IO。
>
> 如何解决粘包问题：
>
> > 粘包问题是在应用层解决的，一可以通过协议表明一个数据包的长度，二可以明确数据包之间的分隔标识，通过标识切割。
> >
> > 如HTTP解决粘包问题使用的是 定长报头+正文长度字段 来保证读取一个完整HTTP数据包。

###### TCP拥塞控制和流量控制的区别

> 拥塞控制是对整个通信网络来说的，避免过多的数据注入到网络中，使网络拥塞进而大量丢包，拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低⽹络传输性能有关的所有因素。
>
> 流量控制是对一条TCP通信链接来说的，是个端到端的问题，控制发送数据速率，确保接收端来得及接收。
>
> 发送窗口受制于拥塞控制和流量控制。

### 数据库

### 笔试

[剑指 Offer 04. 二维数组中的查找 - 力扣（LeetCode）](https://leetcode.cn/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/)

## 2

### C++

### OS

###### 进程与线程的区别

> - 进程是系统资源的最小分配单位，创建进程需要分配地址空间+PCB(process control block)资源，切换复杂
>
> - 线程是CPU调度的最小单位，创建线程只需要分配PCB资源，切换简单
> - 进程之间数据是独立的，进程通信需要IPC
> - 线程之间共享进程的数据，但也有自己的栈和CPU寄存器，线程通信简单但存在线程安全问题
>
> - 并且，LINUX下，进程与线程都是轻量级进程

###### 进程通信方式

> 管道：匿名管道和命名管道，基于内存文件的通信(管道是内存文件)，自带同步与互斥机制
>
> > 匿名管道适用于具有父子关系的进程，先pipe后fork，匿名管道是纯粹的内存文件，在磁盘上无映射
> >
> > 命名管道适用于无父子关系的进程，先mkfifo后open，命名管道也是内存文件，但在磁盘上有映射(仅映射不刷新)
> >
> > 管道特点：自带同步与互斥机制，生命周期随进程，流式服务，(特殊的)半双工通信，内存级文件
>
> systemV共享内存：基于物理内存的通信(进程通过页表映射到同一块物理内存)，速度最快的进程通信方式，但需要自己保证数据安全
>
> > 不同进程通过页表映射同一块物理内存，是速度最快的进程通信方式
> >
> > 需要自己进行访问控制
>
> systemV消息队列/信号量，socket本地进程通信
>
> > 不熟

###### 僵尸进程是什么，为什么会产生僵尸进程

> 是什么：如果一个进程已经终止，并且它的父进程尚未调用wait()/waitpid()对他进行清理，这时该进程的进程状态称为僵死状态，该进程就是僵尸进程
>
> 产生原因：任何一个子进程(init除外)在退出之后，其对应的PCB不会立马被回收，需要等待父进程读取PCB保存的进程退出信息后才会回收，在进程退出和父进程读取这个时间段，该进程就是状态为Z的僵尸进程
>
> 解决方法：
>
> > 1. 通过信号SIGCHLD，自定义父进程对子进程退出的处理动作，该方法对所有子进程退出生效
> > 2. 将进程转换为孤儿进程，由init进程收养并清理

###### 虚拟内存到物理内存的寻址方式

> Linux中每个进程都有专属页表，页表中存储着虚拟地址到物理地址的映射关系，通过页表中的地址映射，实现 虚拟内存到物理内存 访问

###### 页表的作用

> > 用户级页表和内核级页表
> >
> > 一级页表和二级页表
>
> 页表是一种数据结构，页表存放在内存当中，页表里存放了虚拟地址与物理地址的对应关系，VA到PA的转换过程其实就是MMU查询和解析页表的过程。
>
> 页表的作用：
>
> > 是物理内存非连续分配的基础，将连续的虚拟内存与不一定连续的物理内存连接起来，将内存的分配(OS)与使用(进程)进行解耦
> >
> > 页表中存储着进程的虚拟内存与系统的物理内存的映射关系

###### 进程调度算法

> 为了确定⾸先执⾏哪个进程以及最后执⾏哪个进程以实现最⼤ CPU 利⽤率，计算机科学家已经定义了⼀些算法， 它们是：   
>
> （1）**先到先服务(FCFS)调度算法：** 从就绪队列中选择⼀个最先进⼊该队列的进程为之分配资源，使它⽴即执⾏并⼀直执⾏到完成或发⽣某事件⽽被阻 塞放弃占⽤ CPU 时再重新调度。   
>
> （2）**短作业优先(SJF)的调度算法：** 从就绪队列中选出⼀个估计运⾏时间最短的进程为之分配资源，使它⽴即执⾏并⼀直执⾏到完成或发⽣某事件⽽被 阻塞放弃占⽤ CPU 时再重新调度。   
>
> （3）**时间⽚轮转调度算法：** 时间⽚轮转调度是⼀种最古⽼，最简单，最公平且使⽤最⼴的算法，⼜称 RR(Round robin)调度。每个进程被分配 ⼀个时间段，称作它的时间⽚，即该进程允许运⾏的时间。   
>
> （4）**多级反馈队列调度算法：** 前⾯介绍的⼏种进程调度的算法都有⼀定的局限性。如短进程优先的调度算法，仅照顾了短进程⽽忽略了⻓进程 。 多级反馈队列调度算法既能使⾼优先级的作业得到响应⼜能使短作业（进程）迅速完成。，因⽽它是⽬前被公认的 ⼀种较好的进程调度算法，UNIX 操作系统采取的便是这种调度算法。   
>
> （5）**优先级调度：** 为每个流程分配优先级，⾸先执⾏具有最⾼优先级的进程，依此类推。具有相同优先级的进程以 FCFS ⽅式执⾏。 可以根据内存要求，时间要求或任何其他资源要求来确定优先级。

### 计网

###### TCP建立连接为什么是三次握手，而不是两次握手？

> 先说结论：三次握手是验证双方建立可靠通信的**最少次数**，并且能够将建立连接失败时的异常链接挂在客户端上(**风险转移**)
>
> 为什么不是两次握手：
>
> > 一次握手：客户端发送SYN，收不到ACK，无法确认C->S链接是否正常，而且只建立了单向通信，且存在**SYN洪泛风险**
> >
> > 二次握手：服务端收到SYN就会建立链接，进入ESTABLISHED状态，而客户端需要收到ACK才会建立链接，若客户端拒收ACK不建立链接，那么**服务器就建立了一个失效的链接，浪费服务器资源**。而且服务器无法确认S->C链接是否正常
> >
> > 三次握手：正常的三次握手CS双方都能确认通信正常，而且客户端比服务端先进入ESTABLISHED状态，客户端成本大于服务端成本

###### 挥手为什么需要有TIME_WAIT状态

> 先说结论：**在正常情况下，确保客户端在服务端之后断开链接**
>
> TIME_WAIT状态存在的必要性：
>
> - 客户端在进行四次挥手后进入TIME_WAIT状态，如果第四次挥手的报文丢包了，客户端在一段时间内仍然能够接收服务器重发的FIN报文并对其进行响应，**能够较大概率保证最后一个ACK被服务器收到**
> - 客户端发出最后一次挥手时，双方历史通信的数据可能还没有发送到对方。因此客户端四次挥手后进入TIME_WAIT状态，还可以保证双方通信信道上的数据在网络中尽可能的消散
> - 引入TIME_WAIT状态就是**争取让主动发起四次挥手的客户端维护这个成本**，如果第四次挥手后，客户端直接进入CLOSED状态，那么第四次挥手ACK丢包，服务器会多次重发第三次挥手FIN，直到关闭。而TIME_WAIT却能在丢包后使客户端响应重发的第三次挥手FIN，这样就使得客户端最后断开链接。

###### TCP协议如何保证数据可靠性

> 滑动窗口：应用层数据包会被分割成TCP认为的最合适的数据块，即使出错，也只会重发数据包的一部分
>
> 流量控制和拥塞控制：可以控制TCP发送端的发送速率，确保TCP接收端的正常接收，避免接收不了而舍弃的包丢失
>
> 校验和：能够验证一个数据块在传输过程中是否发生修改
>
> 32位序列号和32确认序列号：能够将数据块有序排放，把有序数据按字节流的方式提交给应用层
>
> 超时重传和快重传：确保丢失的数据的重新发送

## 3

###### C++类和结构体的区别

> **默认权限不同**
>
> - 结构体的成员默认访问权限和默认继承方式都是public
>
> - C++类的成员默认访问权限和默认继承方式都是private

###### 类内静态变量在什么时候初始化

> 在C++中，静态变量分为全局静态变量（又称全局变量）、局部静态变量（函数中的静态变量）和类中静态成员变量。按照初始化的类型分为静态初始化（static initialization）和动态初始化(dynamic initialization)
>
> 全局变量、文件域的静态变量和类的静态成员变量**在main执行之前的静态初始化过程中分配内存并初始化**；
>
> 局部静态变量（一般为函数内的静态变量）在**第一次使用时分配内存并初始化**。这里的变量包含内置数据类型和自定义类型的对象。
>
> **全局静态变量/全局变量/类的静态成员变量**
>
> > - **程序加载前初始化**，即编译时就已经初始化，分为静态初始化和动态初始化
>
> **局部静态变量**
>
> > - C语言中，和全局静态变量一样，程序加载前初始化
> > - C++中，**在执行相关代码时才会进行初始化**，主要是由于C++引入对象后，要进行初始化必须执行相应构造函数和析构函数，在构造函数或析构函数中经常会需要进行某些程序中需要进行的特定操作，并非简单地分配内存。**所以C++标准定为全局或静态对象是有首次用到时才会进行构造，并通过atexit()来管理。在C++中是可以使用变量对静态局部变量进行初始化的**
>
> 根据 C++ 标准，全局变量的初始化要在 main 函数执行前完成，常识无疑，但是这个说法有点含糊，main 函数执行前到底具体是什么时候呢？是编译时还是运行时？**答案是既有编译时，也可能会有运行时(seriously)**
>
> **静态初始化**
>
> > 静态初始化指的是用常量来对变量进行初始化,主要包括 zero initialization 和 const initialization，静态初始化在程序加载的过程中完成，对简单类型(内建类型，POD等)来说，从具体实现上看，zero initialization 的变量会被保存在 bss 段，const initialization 的变量则放在 data 段内，程序加载即可完成初始化，这和 c 语言里的全局变量初始化基本是一致的。
>
> **动态初始化**
>
> > 动态初始化主要是指需要经过函数调用才能完成的初始化，比如说：int a = foo()，或者是复杂类型（类）的初始化（需要调用构造函数）等。这些变量的初始化会在 main 函数执行前由运行时调用相应的代码从而得以进行(函数内的 static 变量除外)。
>
> ~~~C++
> class A
> {
> public:
> 	A()
> 	{
> 		cout << "I am A" << endl;
> 	}
> 	A(const A&a)
> 	{
> 		cout << "I am A : a" << endl;
> 	}
> 	~A()
> 	{
> 		cout << "I am ~A" << endl;
> 	}
> };
> class B
> {
> public:
> 	B()
> 	{
> 		cout << "I am B" << endl;
> 	}
> 	~B()
> 	{
> 		cout << "I am ~B" << endl;
> 	}
> 	static A a;
> };
> A B::a; // 1
> 
> int func()
> {
> 	static B b; // 3
> 	return 1;
> }
> int aaaa = func(); // 4
> B bb; // 2
> int main()
> {
> 	cout << "main()" << endl;
> 
> 	A aa;
> 	static A aaa = aa; // 5
> 	//func();
> 
> 	cout << "~main()" << endl;
> 	return 0;
> }
> ~~~

###### 类内普通成员函数可以调用类内静态变量吗，类内静态成员函数可以访问类内普通变量吗？

> - 类内静态变量和类是相关的，非静态成员函数就可以通过this指针找到类，进而找到静态成员变量，也可以使用类作用符
>
> - 类内普通变量是和实例对象相关的，静态成员函数没有this指针，找不到实例对象，则也找不到非静态成员变量

###### 虚析构函数的作用

> **保证派生类资源的安全释放**
>
> 当基类指针指向派生类对象时，若基类的析构函数不定义为虚函数，则通过基类指针析构时，只会调用基类的析构函数而不会调用派生类的析构函数，此时派生类部分的内存就没有释放，从而导致内存泄漏。
>

###### vector存储的内容可以是引用吗?指针呢？

> 不可以是引用，可以是指针
>
> **C++中不允许定义或声明指向引用的指针**，而STL库的容器如vector都需要实现迭代器，这些**迭代器的实现是依赖于底层数据的指针**的，所以底层数据类型是引用的话，会出现 引用的指针 **错误**

###### map的底层数据结构是什么？为什么不是AVL

> map/set的底层数据结构是红黑树RBT。
>
> AVL树严格要求平衡，左右子树的高度差不能大于1；而RBT要求相对宽松，但也要求最长路径不能大于最短路径两倍
>
> 查找都是LOG级别
>
> 因为AVL严格要求平衡，则插入删除操作更大概率引发多次旋转操作；而红黑树的插入删除操作小概率引发少次旋转操作

###### 类的多态如何实现

> - 派生类继承父类
> - 父类虚函数必须声明为virtual
> - 子类对应函数进行重写
> - 父类的指针或引用调用虚函数，根据实例对象的不同产生不同的效果