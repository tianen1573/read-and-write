#### 其他

#### 亿联-9.11

###### 左旋转字符串

[剑指 Offer 58 - II. 左旋转字符串 - 力扣（LeetCode）](https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/?envType=study-plan-v2&envId=coding-interviews)

###### 约瑟夫环

[约瑟夫问题及其变形_约瑟夫问题变形_Coco_T_的博客-CSDN博客](https://blog.csdn.net/wu_tongtong/article/details/78323654)

#### 腾讯笔试-9.10

> C:\Users\41525\Desktop\Training_And_OJ\2023\PastPapers\TenCent2023

1. 二叉树DFS
2. 优先队列：力扣中位数
3. 排序+贪心
4. 共生团：不会
5. 分组背包

#### 深信服-9.6

###### 组合数-DP

> **C(N, k) = C(N - 1, k) + C(N - 1, k + 1)**

[LCR 104. 组合总和 Ⅳ - 力扣（LeetCode）](https://leetcode.cn/problems/D0F0SV/description/)

[LCR 080. 组合 - 力扣（LeetCode）](https://leetcode.cn/problems/uUsW3B/)

###### 分割回文串-DP

[LCR 094. 分割回文串 II - 力扣（LeetCode）](https://leetcode.cn/problems/omKAoA/?envType=study-plan-v2&envId=coding-interviews-special)

###### 斐波那契数列DP

#### 滴滴-9.8

###### 二分+模拟

> 一个工厂可以生成n种产品，每种商品每天可以生产arr[i]个
>
> 给这个工厂分配的任务是生产m包，且每包不能少于k个
>
> 问：该工厂至少需要多少天才能完成这个任务？

~~~
二分模拟：AC

l = 1, r = 极限天数
mid = (l + r) >> 1
if(mid生产的包数cnt >= m)
	r = mid;
else
	++ l;
~~~

###### 字典树？

> 给你一个字符串数组，问有多少个字符串满足一下条件
>
> - 该字符串S 是 A+B串去除一个不为空的前缀后缀后的 子串
> - A，B可以重复，且可以是S自己

~~~
枚举+字典树：未验证

将数组中的每个字符串都与数组中的字符串合并成该形式：AB、BA、AA
然后将合并后的字符串SS，用 枚举去除前缀后缀(不能为空)后的字串 构建字典树
再枚举数组，判断元素是否存在于字典树中
~~~

[9.8 滴滴笔试_牛客网 (nowcoder.com)](https://www.nowcoder.com/feed/main/detail/bf4ff088588c40038226192ce143b43c?anchorPoint=comment)

#### CVTE-9.11

###### 合并有序链表

> 将两个降序的链表合并成一个升序的链表

头插/尾插：[剑指 Offer 25. 合并两个排序的链表 - 力扣（LeetCode）](https://leetcode.cn/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/)

堆优化：[LCR 078. 合并 K 个升序链表 - 力扣（LeetCode）](https://leetcode.cn/problems/vvXgSW/)

###### 两数之和

[1. 两数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/two-sum/solutions/434597/liang-shu-zhi-he-by-leetcode-solution/)

#### 美团/京东测开-9.9

#### 同花顺-9.8

#### 百度-9.12

> C:\Users\41525\Desktop\Training_And_OJ\2023\PastPapers\Baidu2023

1. 数学题：简单模拟
2. 简单模拟
3. 二分+区间和

#### 腾讯补考-9.15

> C:\Users\41525\Desktop\Training_And_OJ\2023\PastPapers\TenCent2023_2

###### 合并无序链表

![image-20230916162823968](%E5%9B%BE%E7%89%87/%E7%AC%94%E8%AF%95/image-20230916162823968.png)

> 优先队列，全部入堆

###### 大堆

![image-20230916162852470](%E5%9B%BE%E7%89%87/%E7%AC%94%E8%AF%95/image-20230916162852470.png)

> 大堆，每次取堆顶，操作后再放进去

###### 排序

![image-20230916163021078](%E5%9B%BE%E7%89%87/%E7%AC%94%E8%AF%95/image-20230916163021078.png)

> 计算位置后排序
>
> 位置相同的解决办法：额外两个变量记录上一个人的位置和排名，维护这两个变量

###### 字符串

![image-20230916163204295](%E5%9B%BE%E7%89%87/%E7%AC%94%E8%AF%95/image-20230916163204295.png)

> **未验证**
>
> 将每个字符串的最小字典序旋转串存起来，判断是集合里是否存在该串

###### 贪心？

![image-20230916163340644](%E5%9B%BE%E7%89%87/%E7%AC%94%E8%AF%95/image-20230916163340644.png)

> **未验证**
>
> 优先改变中间的蓝色节点

#### FunPlus-9.15

> C:\Users\41525\Desktop\Training_And_OJ\2023\PastPapers\FunPlus2023

###### 模拟

判断五张扑克牌按照数字大小是不是顺子

大小王可以为任意牌，A可以为14

> 记录每张排的个数，其中A即为1又为14，大小王为0
>
> 模拟遍历是否有连续的5张牌，0可以替换成其他盘

###### 实数表达式

构建一个**实数表达式**，能不能计算出某个值

如：8 / (1 - 2 / 3) = 24

> ？？？

#### 剑心互娱-9.16

###### 滑动窗口优化

![image-20230916163906112](%E5%9B%BE%E7%89%87/%E7%AC%94%E8%AF%95/image-20230916163906112.png)

**滑动窗口：N\*K(K为出队入队的平均次数)***

> AC
>
> 滑动窗口需要优化一下，比如我们要求滑动窗口的大小必须大于等于3，则就可以减少滑动的次数，也可以减少出队的次数。
>
> 此时，我们再模拟窗口大小为2的时候是否存在满足条件的窗口。
>
> ~~~C++
> class Solution {
> public:
>     /**
>      * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
>      *
>      * 求奇序列数
>      * @param nNum int整型 指定的数字
>      * @return int整型
>      */
>     int Calc(int nNum) {
>         
>         if(nNum <= 3)
>             return 0;
> 
>         int ans = 0;
>         queue<unsigned int> que;
>         unsigned int val = 1;
>         unsigned int sum = 0;
>         int maxNum = nNum / 3 + 5;
>         while(val < maxNum)
>         {
>             sum += val;
>             que.push(val);
> 
>             while(sum > nNum)
>             {
>                 sum -= que.front();
>                 que.pop();
>             }
>             if(sum == nNum && que.size() > 2)
>             {
>                 ++ ans;
>             }
> 
>             val += 2;
>         }
>         cout << ans;
>         val = 3;
>         while(true)
>         {
>             unsigned int tmp = (val - 1) << 1;
>             if(tmp == nNum)
>                 ++ ans;
>             else if(tmp > nNum)
>                 break;
>         
>             val += 2;
>         }
> 
>         return ans;
> 
>     }
> };
> ~~~
>
> 

**DP：N\*K(K为对应数组的长度)**

> 未验证
>
> 因为是连续的奇数序列，则奇数i一定需要依靠i-2
>
> 我们给每个奇数维护一个数组，用来保存以i结尾的序列的序列和
>
> 如果序列和大于目标值，我们就舍弃该序列和；如果等于目标值就进行记录

**数学公式+二分：N\*logN**

> 连续的奇数序列是一个等差公式，我们可以枚举序列的最小奇数，然后去二分右端点：最小奇数+2，最大奇数

###### 图形几何

![image-20230916171125652](%E5%9B%BE%E7%89%87/%E7%AC%94%E8%AF%95/image-20230916171125652.png)

###### 编码解码

![image-20230916171232227](%E5%9B%BE%E7%89%87/%E7%AC%94%E8%AF%95/image-20230916171232227.png)

~~~C++
#include<iostream>
#include <vector>

using namespace std;

string tmp;
string GetIntArryString(vector<int>& Data)
{
	string strRet = "";
	const char* szIndex = "0123456789ABCDEF";
	int nZeroCount = 0;
	int nMask = 0xF;
	for (int i = 0; i < Data.size() * 8; ++i)
	{
		int nPos = (7 - i % 8) * 4;
		uint8_t uValue = (Data[i / 8] & (nMask << nPos)) >> nPos;
		tmp.push_back(uValue + '0');
		if ((uValue && nZeroCount) || (nZeroCount == ('z' - 'a' + 2)))
		{
			strRet.push_back((nZeroCount > 1 ? ('a' + nZeroCount - 2) : '0'));
			nZeroCount = 0;
		}
		if (!uValue)
		{
			nZeroCount++;
		}
		else
		{
			strRet.push_back(szIndex[uValue]);
		}
	}
	if (nZeroCount > 0)
	{
		strRet.push_back((nZeroCount > 1 ? ('a' + nZeroCount - 2) : '0'));

	}
	return strRet;
}

int main()
{
	vector<int> arr = { 16, 17};
	GetIntArryString(arr);

	return 0;
}
~~~

> 未验证
>
> 读取第一个字符代表第一个数的数位，然后本应该读取对应数位的字符就行了
>
> 但是(1)有可能压缩0，(2)有可能和下一位结合
>
> 如果没读够位数就读到了小写字符，则一定缩0会结合了
>
> 把这个小写字符转换成缩的0的个数
>
> 如果大于剩余的个数则代表结合了
>
> abcdef，f代表位数为1
>
> abcdef，a代表有2个0



